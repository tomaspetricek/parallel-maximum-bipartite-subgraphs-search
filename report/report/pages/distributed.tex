Poslední způsob, jak rozdělit práci, bylo rozdělit ji mezi více procesorů.
Doposud bylo využito pouze výhody více jádrových procesorů.
Na clusteru jsme měli přístup k více uzlům, na kterých bylo možné současně spustit hledání nejlepšího stavu.
Vzor \textbf{master-slave} byl použit k implementaci distribuovaného algoritmu.
Koncept spočívá v tom, že je jeden proces zvaný \textit{master}, jehož úkolem je připravit práci, a zbylé procesy se nazývají \textit{slave}, jejichž úkolem je provést práci.
Z principu vzoru vyplývá, že pro implementaci musí být spuštěny alespoň 2 procesy.
Další důležitou věcí je, že procesy spolu musí komunikovat a k tomu byl použit \textbf{MPI} framework.
Poskytuje sadu funkcí, které se používají k odesílání a přijímání zpráv různými způsoby.

Chcete-li spustit program na více procesech, musíte použít příkaz jako \textbf{mpirun} ke spuštění a propojení procesů.
Vlajka \textit{np} se používá k určení počtu procesů, které se mají spustit.
Na konci příkazu je uveden spustitelný soubor se svými vlajkami.
Příklad příkazu je uveden ve výpisu \ref{lst:distrib:mpirun}.

\begin{lstlisting}[language=C++, label={lst:distrib:mpirun}, title={Příklad použití příkazu mpirun}]
mpirun -np 4 /MBPCombined -f graf_10_3.txt -o distrib.csv -m "DISTRIB" -dm 4 -ds 4 -t 3
\end{lstlisting}

K funkcím MPI lze přistupovat zahrnutím hlavičkového souboru.
Nicméně framework je však napsán v jazyku C na velmi nízké úrovni, a proto bylo výhodnější použít knihovnu \textbf{Boost.MPI}, která je více objektově orientovaná.
Používá také knihovnu \textbf{Boost.Serialization}, která se používá k serializaci a deserializaci objektu, aby jej bylo možné převést na pole bajtů, odeslat přes síť a znovu sestavit.
Aby byl objekt serializovatelný, musí být implementována metoda \texttt{serialize}, což je velmi jednoduché a intuitivní (viz \ref{lst:distrib:serialize}).

\begin{lstlisting}[language=C++, label={lst:distrib:serialize}, title={Příklad implementace metody serialize}]
    friend class boost::serialization::access;
    template<class Archive>
    void serialize(Archive& archive, const unsigned int version)
    {
        archive & BOOST_SERIALIZATION_NVP(init);
        archive & BOOST_SERIALIZATION_NVP(best);
    }
\end{lstlisting}

Pro inicializaci prostředí pro zasílání zpráv je vytvořena instance třídy \texttt{boost::mpi::environment}.
Funkce \texttt{MPI\_Init} je volána během konstrukce objektu a \texttt{MPI\_Finalize} je volána při jeho destrukci.
Poté je vytvořena instance \texttt{boost::mpi::communicator}, která odpovídá funkci \texttt{MPI\_COMM\_WORLD}.
Slouží ke komunikaci mezi procesy.
Může být použita k identifikaci ranku procesu voláním metody \texttt{rank}.
Proces s rankem 0 (\texttt{process::rank::master}) je master proces, všechny ostatní ranky identifikují slave procesy.
Pro zapouzdření práce procesů byly vytvořeny třídy \texttt{process::master} a \texttt{process::slave}.
Jelikož v každém procesu běží stejný kus kódu, bylo nutné implementovat jednoduchou logiku pro odlišení procesů (viz \ref{lst:distrib:run}).

\begin{lstlisting}[language=C++, label={lst:distrib:run}, title={Rozdělení procesů}]
void run_distributed(...)
{
    // start MPI environment
    boost::mpi::environment env;
    boost::mpi::communicator world;

    ...

    if (world.rank()==process::rank::master) {
        ...
        
        auto proc = process::master(world, graph, master_explorer, slave_explorer);
        auto res = measure_duration([&] { return proc.start(); });
        
        ...
    }
    else {
        auto proc = process::slave(world);
        proc.start();
    }
}
\end{lstlisting}

Třída \texttt{process::master} bere jako parametr konstruktoru komunikátor, graf a explorer pro master a slave proces.
Jakmile je proces spuštěn, tak si připraví počáteční stavy pomocí metody \texttt{prepare\_states}, která používá instanci třídy \texttt{finder::data\_parallel}.
Poté se zavolá metoda \texttt{manage\_slaves} (viz \ref{lst:distrib:manage_slaves}), která nejprve spustí slave procesy.
Pošle jim instanci třídy \texttt{setting}, které se skládá z grafu a slave exploreru, a poté jim pošle objekt třídy \texttt{config} složené z nejlepšího stavu známého masterem a počátečního stavu.
K sdělení obsahu zprávy používá štítky \texttt{tag::setting} a \texttt{tag::config}.
Poté čeká, až nějaký proces vrátí nejlepší lokální stav.
K určení, že čeká na zprávu od jakéhokoli procesu, používá \texttt{boost::mpi::any\_source}.
Když stav obdrží, pokusí se aktualizovat nejlepší stav, a poté odešle novou konfiguraci.
Pokračuje v odesílání konfigurací, dokud nevyčerpá počáteční stavy.
Nakonec odešle zpět \texttt{tag::stop}, který říká slave procesu, aby se ukončil.

\begin{lstlisting}[language=C++, label={lst:distrib:manage_slaves}, title={Metoda pro obstarání slave procesů}]
    void manage_slaves(const std::vector<finder::state>& init_states)
    {
        pdp::setting setting(graph_, slave_explorer_);
        finder::state local_best;
        boost::mpi::status status;

        for (int i{0}; i<init_states.size()+world_.size(); i++) {
            // start working
            if (i<world_.size()-1) {
                world_.send(i+1, tag::setting, setting);
                world_.send(i+1, tag::config, config(init_states[i], best_));
            }
            // keep working
            else if (i<init_states.size()) {
                status = world_.recv(boost::mpi::any_source, tag::done, local_best);
                try_update_best(local_best);
                world_.send(status.source(), tag::config, config(init_states[i], best_));
            }
            // stop working
            else if (i>init_states.size()) {
                status = world_.recv(boost::mpi::any_source, tag::done, local_best);
                try_update_best(local_best);
                world_.send(status.source(), tag::stop, config());
            }
        }
    }
\end{lstlisting}

Slave proces reprezentovaný třídou \texttt{process::slave} je mnohem jednodušší.
Skládá se pouze z jedné veřejné metody \texttt{start} (viz \ref{lst:distrib:start}, která nejprve příjme nastavení, a poté buď najde nejlepší stav pro danou konfiguraci nebo se ukončí.
Jelikož neví, co obdrží, používá štítek \texttt{boost::mpi::any\_tag} jako parametr metody \texttt{recv}.
K nalezení nejlepšího stavu používá instanci \texttt{finder::data\_parallel}.

\begin{lstlisting}[language=C++, label={lst:distrib:start}, title={Hlavní metoda třídy slave procesu}]
    void start()
    {
        ...

        // receive settings
        pdp::setting setting;
        world_.recv(rank::master, tag::setting, setting);;
        finder::data_parallel finder{setting.graph, setting.explorer};

        // keep working
        while (true) {
            status = world_.recv(rank::master, boost::mpi::any_tag, config);

            // stop working
            if (status.tag()==tag::stop) {
                return;
            }

            // find best
            finder.best(config.best);
            best = finder.find(config.init);
            world_.send(rank::master, tag::done, best);
        }
    }
\end{lstlisting}





